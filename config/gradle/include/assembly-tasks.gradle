import com.iteego.glasir.build.tasks.*
import com.iteego.glasir.build.api.tasks.*

buildscript { 
  repositories             RepositoryConfigurator
  dependencies             DependencyConfigurator
  configurations.classpath ResolutionConfigurator
}

configurations.create('entityresolver') 
dependencies { 
  entityresolver 'com.iteego.glasir:glasir.entityresolver:1.0'
}

String getAllEnvironmentModules() {
  glasir.model.modules.collect { it.name }.findAll { it.startsWith('env.') || it == 'env' }.sort().join(" ")
}

task atgCoreSqlInstallationOrder << {
  description = "Displays build/install/sql ordering for ATG core modules."
  printAtgCoreSqlInstallationOrder()
}

task assembleReleaseEar(type: AtgAssemblerTask, description: "Runs a build and assembles a release ear") {
  dependsOn "build", "syncAtgServers"
  //dependsOn "build"

  modules = getAllEnvironmentModules()
  outputFile = bigEar
  standalone = true
  liveConfig = true
  pack = true
  
  searchRootDirs = files("$atgRoot", "$rootDir", "$rootDir/packages", "$rootDir/packages/modules/glasir")
  loggingDebug = false

  //doAfterAssembly is called after the ear is assembled (into an exploded stage dir)
  //but before the ear is packed
  doAfterAssembly {
    copy {
      //TODO: Fix the config/atg dir structure for release ears
      file("${rootDir}/config/atg").eachDir { from it }
      into "${bigEar.canonicalPath}.exploded/atg_bootstrap.war/WEB-INF/ATG-INF/home/servers"
    }
  }
}

task assembleDevEar(type: AtgAssemblerTask, description: "Runs a build and assembles a development ear") {
  dependsOn "build", "syncAtgServers"
  //dependsOn "build"

  modules = allEnvironmentModules
  outputFile = bigEar
  standalone = false
  runInPlace = true
  
  liveConfig = false
  pack = false
  loggingDebug = false
  glasirDevMode = true
  useInitializer = true
  
  //TODO: Figure out if there is a clean way of making the atg assembler find all the required stuff
  searchRootDirs = files("$atgRoot", "$rootDir", "$rootDir/packages", "$rootDir/packages/modules/glasir")

  // Make sure to first remove the ear file, so that the assembler does not try to write files into any folder
  // that contains symbolic links. If there would be any symbolic links in an already existing ear file,
  // the assembler would simply follow them and write into their destination directory, which in our case is
  // the source tree. By removing the ear file safely before starting the assembler, we avoid clobbering our
  // source tree with assembler output files.
  doFirst {
    glasir.deleteDir(bigEar)
  }
}

def getOnWindows () {
  System.properties['os.name'].toLowerCase().startsWith("windows")
}

task copyStoreEar(type: Copy, description: "Copies the ear file into the deploy directory of the JBOSS server") {
  dependsOn "syncStoreJBossServer"
  def target = "$jBossRoot/server/$storeServerName/deploy/${bigEarName}"
  from bigEar
  into target
}

task linkStoreEar(description: "Creates a symbolic link from the store ear file to the big ear") << {
  def target = "$jBossRoot/server/$storeServerName/deploy/${bigEarName}"
  ant.symlink( link: target, resource: bigEar, overwrite: true)
}

linkStoreEar.dependsOn "syncStoreJBossServer"

task copyAdminEar(type: Copy, description: "Copies the ear file into the deploy directory of the JBOSS server, if on Windows, otherwise use a symbolic link") {
  dependsOn "syncAdminJBossServer"
  def target = "$jBossRoot/server/$adminServerName/deploy/$bigEarName"
  from bigEar
  into target
}

task linkAdminEar(description: "Copies the ear file into the deploy directory of the JBOSS server, if on Windows, otherwise use a symbolic link") << {
  def target = "$jBossRoot/server/$adminServerName/deploy/$bigEarName"
  ant.symlink( link: target, resource: bigEar, overwrite: true)
}

linkAdminEar.dependsOn "syncAdminJBossServer"

task syncStoreEar(description: "Copies the ear file into the deploy directory of the JBOSS server, if on Windows, otherwise use a symbolic link") {
  String action = (onWindows || isReleaseBuild) ? "copyStoreEar" : "linkStoreEar"
  dependsOn action
}

task syncAdminEar(description: "Copies the ear file into the deploy directory of the JBOSS server, if on Windows, otherwise use a symbolic link") {
  String action = (onWindows || isReleaseBuild) ? "copyAdminEar" : "linkAdminEar"
  dependsOn action
}

task syncStoreJBossServer(type: Copy, description: "Creates a dev server setup in your jboss installation") {
  from("$jBossRoot/server/default")
  from "$rootDir/config/jboss/store/dev"
  into "$jBossRoot/server/$storeServerName"
}

task syncAdminJBossServer(type: Copy, description: "Creates a dev server setup in your jboss installation") {
  from "$jBossRoot/server/default"
  from "$rootDir/config/jboss/admin/dev"
  into "$jBossRoot/server/$adminServerName"
}

task syncDocRoot(type: Copy) {
    from docRoot
    into "$jBossRoot/server/${storeServerName}/deploy/ROOT.war"
}

task syncAtgServers(type: Copy) {
    from "${rootDir}/config/atg"
    into "$atgRoot/home/servers"
    //into "$jBossRoot/ATG-Data/servers"

    // Make sure to first remove the existing server directories, so that the copy task does not try to write files
    // into any folder that contains symbolic links. If there would be any symbolic links in an already existing
    // destination folder, the copy task would simply follow them and write into their target directory,
    // which in our case is the source tree. By removing the directories safely before starting the copy,
    // we avoid clobbering our source tree with build output files.
    doFirst {
        glasir.deleteDir("$atgRoot/home/servers/$storeServerName")
        glasir.deleteDir("$atgRoot/home/servers/$adminServerName")
        //glasir.deleteDir("$jBossRoot/ATG-Data/servers/$storeServerName")
        //glasir.deleteDir("$jBossRoot/ATG-Data/servers/$adminServerName")
    }
}

task syncStore(dependsOn: [syncStoreEar, syncDocRoot])

task syncAdmin(dependsOn: [syncAdminEar])

task devDeploy {
  description = "Compile, test, assemble, and deploys the dev ear to jboss"  
  dependsOn = [assembleDevEar, syncStore, syncAdmin, syncAtgServers]
  //dependsOn = [assembleDevEar, syncStore, syncAdmin, syncAtgServers]

  doLast { 
    if (!onWindows) {
      def mainAppDir = new File("${rootDir}/glasir-app")

      // Link all top-level application modules from source tree
      def destinationDir = "$jBossRoot/server/${storeServerName}/deploy/${bigEarName}/atg_bootstrap.war/WEB-INF/ATG-INF"
      glasir.model.topModules.each {
        def linkName = "${destinationDir}/${it.name}"
        glasir.deleteDir(linkName)
        ant.symlink( link: linkName, resource: it.dir, overwrite: true)
      }

      // Link all war webapp folders from source tree
      destinationDir = "$jBossRoot/server/${storeServerName}/deploy/${bigEarName}"
      glasir.model.webModules.findAll { !it.isAtgCore }.each { m ->        
        def linkName = "$destinationDir/${m.dir.name}"
        glasir.deleteDir(linkName)
        ant.symlink( link: linkName, resource: m.dir, overwrite: true)
      }

      // Copy all atg server directories from source tree
      // note that we cannot use symbolic linking for the atg servers
      // because when the nodes start up, they clobber those directories with ample run-time data
      // meaning we would get lots of runtime files into the source tree if we were to symlink instead of copy
      copy {
        from file("${rootDir}/config/atg")
        into file("$jBossRoot/ATG-Data/servers")
      }

      
      def dynamoEnv = file("${bigEar}/atg_bootstrap.war/WEB-INF/ATG-INF/dynamo.env")
      dynamoEnv.text = dynamoEnv.text.readLines().collect { line ->
        line.startsWith('atg.dynamo.server.home') ? "atg.dynamo.server.home=${atgRoot}/home"
                                                  : line
      }.join("\n")

      mkdir("${atgRoot}/home/servers/dev-store/localconfig")
    }

  }

}

def atgServers() {
  def servers = []
  file("${rootDir}/config/atg").eachDir {
    servers << it
  }
  servers
}


task cleanLocalDatabase(dependsOn: ['clean']) << {
  description = "Cleans out the local database, if any"
  glasir.deleteDir(databaseDir)
}

task cleanJbossServers(dependsOn: ['clean']) << {
  description = "Cleans out the jboss server dirs"
  glasir.deleteDir("$jBossRoot/server/${storeServerName}")
  glasir.deleteDir("$jBossRoot/server/${adminServerName}")
  glasir.deleteDir("$jBossRoot/ATG-Data")
}

task cleanAll(dependsOn: ['clean','cleanJbossServers','cleanLocalDatabase']) << {
  description = "Cleans out all the 'build' directories in the source tree, the jboss server dirs and the local database, if any"
}
