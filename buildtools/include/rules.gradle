/*****************************************************************************
* Add a rule for printing the dependency tree of an
* arbitrary ATG module. Example ATG has a module called
* 'DCS', the below will let you execute "gradle printDCS"
*/
tasks.addRule("""\
Pattern: print<AtgModuleName>: Prints a module dependency tree for an atg module
         Example: 'gradle printDCS.Search.Order.Index' will print out dependency tree for
                  module 'DCS.Search.Order.Index'""") { String taskName ->
  if (taskName.startsWith("print")) {
    task(taskName) << {
      moduleMap.each { k, v -> 
        println v
      }
      printTree(taskName - "print")
    }
  }
}

tasks.addRule("""\
Pattern: checkManifest<AtgModuleName>: Checks the module MANIFEST.MF against the contents of 
         the <module root>/lib directory to see if the ATG-Class-Path contains all the jars 
         in the lib directory and vice versa""") { String taskName ->
  if (taskName.startsWith("checkManifest")) {
    task(taskName) << {
      def moduleName = (taskName - "checkManifest")
      def m = module(moduleName)
      Set<File> cpFiles = m.fullClasspath
      Set<File> libFiles = []      
      new File(m.dir, "lib").eachFileRecurse { f -> 
        libFiles << f
      }
    
      def inCpNotInLib = (cpFiles - libFiles).findAll { it.canonicalPath.contains(m.dir.canonicalPath) } 
      if (inCpNotInLib) {
        println "Files referred to in MANIFEST.MF ATG-Class-Path that do not exist on disk:"
        (inCpNotInLib).sort { a, b -> a.name.compareTo(b.name) }.each {
          if (!it.canonicalPath.contains(m.dir.canonicalPath)) return
          println "  $it"
        }
      } else {
        println "All the files in the MANIFEST.MF ATG-Class-Path attribute exist - OK" 
      }
      
      println ""
      def inLibNotInCp = (libFiles - cpFiles)
      if (inLibNotInCp) {
        println "Files in <moduleDir>/lib which are not referred to in MANIFEST.MF ATG-Class-Path:"
        inLibNotInCp.sort { a, b -> a.name.compareTo(b.name) }.each {
          println "  $it"
        }      
      } else {
        println "All the files <moduleDir>/lib are referred to in MANIFEST.MF ATG-Class-Path - OK" 
      }
    }
  }
}

tasks.addRule("""\
Pattern: graph<AtgModuleName>: draws a graphical dependency graph for the specified ATG module""") { String taskName ->
  if (taskName.startsWith("graph")) {
    task(taskName) << {
      def moduleName = taskName - 'graph'
      def m = moduleMap[moduleName]
      if (!m) {
        println "Unable to locate module with name '$moduleName'"
        System.exit(1)
      }
      def dotGraph = createGraphViz(m)
        
      def chartParams = [cht: 'gv', chof: 'png', chl: dotGraph]
      def url = "http://chart.googleapis.com/chart?" 
      url += chartParams.collect {k,v -> "$k=${URLEncoder.encode(v)}"}.join('&')
    
      def graphFile = file("$reportsDir/module_graph.png")
      graphFile.withOutputStream{out ->
        out << new URL(url).openStream()
      }   
      println "ATG module dependency graph written to: ${graphFile.absolutePath}"
    }    
  }
}

String createGraphViz(m) {
  Set<String> edges = [] as Set
  String dotGraph = "digraph Compile { \n"
  
  dotGraph += createGraphVizRecursive(edges, m)
    
  dotGraph += "}"
  
  dotGraph
}

String createGraphVizRecursive(edges, parent) {
  String graph = ''
  
  parent.requiredModules.each { child ->    
    if (!child) {
      println "$parent has null child, modules: ${parent.requiredModules}"
      return
    }
    
    String entry = getGraphVizEntry(parent, child)
    if (!edges.contains(entry)) {
      graph += entry
      edges << entry
    }
    graph += createGraphVizRecursive(edges, child)
  }  
  
  graph
}

String getGraphVizEntry(parent, child) {
  /  "${child.name}" -> "${parent.name}"/ + "\n"
}
/*
compileDepsPng = file("$reportsDir/compileDeps.png")
task dependenciesPng() {
  
  inputs.files subprojects.configurations.compile
  outputs.files compileDepsPng
  doFirst {
    if(compileDepsPng.exists()) compileDepsPng.delete()
    if(!reportsDir.exists()) reportsDir.mkdirs()
  
  }
  doLast {
    dotGraph = "digraph Compile{"
    subprojects.each {subproject ->
      subproject.configurations.compile.dependencies.each { dependency ->
        if(dependency instanceof ProjectDependency) {
          
          dotGraph += "\"$subproject.name\" -> \"$dependency.name\"" 
        }   
      }
    }
    dotGraph += "}"
  
  }
}
*/