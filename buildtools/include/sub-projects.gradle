
/******************************************************************************
 * Gradle project and sub-project setup calls
 *****************************************************************************/

//TODO: We need to figure this out! Seems like if you _don't_ create dependencies 
//on subprojects, then it is non-trivial to depend on all child projects with a 
//specific task defined. If you _do_ add them, it becomes impossible to configure 
//the projects individually via specific project build.gradle files. 
gradle.projectsEvaluated { g ->
  build.dependsOn(getTasksByName('build', true) - build)
  clean.dependsOn(getTasksByName('clean', true) - clean)
}

/*
subprojects.each { p ->
  if (p.path.startsWith(":glasir")) return
  evaluationDependsOn(p.path)
}
*/

// Add some behavior to all projects including the root one.
allprojects {
  apply plugin: 'groovy'
  
  repositories {
    mavenCentral()
  }

  dependencies {
    def groovyVersion = "org.codehaus.groovy:groovy:1.8.3"

    // The below enables us to write atg classes in mixed java/groovy. Groovy
    // jar will be downloaded and cached from a maven repo on demand.
    groovy groovyVersion

    testCompile "junit:junit:4.8.2", 
                "org.mockito:mockito-all:1.8.5",
		            groovyVersion

    compile  "junit:junit:4.8.2", 
              "org.mockito:mockito-all:1.8.5"
  }

  sourceCompatibility = "1.6"
  targetCompatibility = "1.6"
  
  compileJava {
    options.compilerArgs = ['-Xlint:deprecation'] //, '-Xlint:unchecked']
  }
}


// Add behavior to all sub-projects (that is: not to the root project).
subprojects {
  // set the maven 'group' for the sub project,
  group = getProjectGroup(project, true)

  test {
    testResultsDir = rootProject.testResultsDir 
    testReportDir = rootProject.testReportDir 
    //maxParallelForks = 10
  }

  setupAtgDependencies(project, ['compile', 'testCompile'])

  // Adds a 'print' task which you can run from the subprojects. I.e. you can cd into a project dir and
  // run 'gradle print' to get a dependency tree for that project.
  task print << {
    printTree(project)
  }

  jar  {
    //only create a jar file if we have some classes to jar up, 
    //to to this we check if the 'compileJava' task did any work (if so, we have something
    //to jar up). TODO: if we need to create resources-only jars, this needs changing
    onlyIf {
      compileJava.didWork || processResources.didWork || compileGroovy.didWork
    }

    // Change where the resulting jar will end up
    destinationDir = file("lib")
    baseName = 'classes'
  }
    
  //this works around the issue described at the following url on the gradle forums: 
  //http://forums.gradle.org/gradle/topics/jar_task_creates_build_dir_even_when_not_executed
  assemble.doLast {
    if (!fileTree(dir: buildDir).find { it.isFile() } ) {
      //println "No work in ${project.path} deleting $buildDir"
      delete(buildDir)
    }
  }
  
  clean << {
    ant.delete file: 'lib/classes.jar'
    if (!file('lib').listFiles()) {
      ant.delete dir: 'lib'
    }
  }
}
