import com.iteego.glasir.build.tasks.*
import com.iteego.glasir.build.api.tasks.*

repositories {
  maven {
    credentials.username artifactoryReader
    credentials.password artifactoryReaderPwd
    url "$artifactoryReaderUrl/glasir"
  }
}

configurations.add('entityresolver') 
dependencies { 
  entityresolver 'com.iteego.glasir:glasir.entityresolver:1.0'
}

def getOnWindows () {
  System.properties['os.name'].toLowerCase().startsWith("windows")
}

String getAllEnvironmentModules() {
  glasir.model.modules.collect { it.name }.findAll { it.startsWith('node.') || it == 'node' }.sort().join(" ")
}

task atgCoreSqlInstallationOrder(description: "Displays build/install/sql ordering for ATG core modules") << {
  printAtgCoreSqlInstallationOrder()
}

task assembleReleaseEar(type: AtgAssemblerTask, description: "Runs a build and assembles a release ear") {
  dependsOn "build", "copyAtgServers"

  modules        = allEnvironmentModules
  outputFile     = bigEar
  standalone     = true
  liveConfig     = true
  pack           = true  
  loggingDebug   = false
  searchRootDirs = files("$atgRoot", "$rootDir", "$rootDir/packages", "$rootDir/packages/modules/glasir")

  //doAfterAssembly is called after the ear is assembled (into an exploded stage dir)
  //but before the ear is packed
  doAfterAssembly {
    copy {
      file("${rootDir}/servers").eachDir { from new File( it, "atg" ) }
      into "${bigEar.canonicalPath}.exploded/atg_bootstrap.war/WEB-INF/ATG-INF/home/servers"
    }
  }
}

task assembleDevEar(type: AtgAssemblerTask, description: "Runs a build and assembles a development ear") {
  dependsOn "build", "copyAtgServers"
  //dependsOn "build"

  modules = allEnvironmentModules
  outputFile = bigEar
  virtualEarFile = file("$rootDir/build/glasir-commerce-ear.vfslink.properties")
  standalone = false
  runInPlace = true
  
  liveConfig = false
  pack = false
  loggingDebug = false
  glasirDevMode = true
  useInitializer = true
  
  //TODO: Figure out if there is a clean way of making the atg assembler find all the required stuff
  searchRootDirs = files("$atgRoot", "$rootDir", "$rootDir/packages", "$rootDir/packages/modules/glasir")

  // Make sure to first remove the ear file, so that the assembler does not try to write files into any folder
  // that contains symbolic links. If there would be any symbolic links in an already existing ear file,
  // the assembler would simply follow them and write into their destination directory, which in our case is
  // the source tree. By removing the ear file safely before starting the assembler, we avoid clobbering our
  // source tree with assembler output files. Note that symbolic linking is only done on non-windows environments.
  doFirst {
    if (!onWindows) {
      glasir.deleteDir(bigEar)
    }
  }
}


task copyDocRoot(type: Copy, description: "Copies the contents of the document root into ROOT.war under JBOSS") {
  from docRoot
  into "$jBossRoot/server/${storeServerName}/deploy/ROOT.war"
}


task copyWars(type: Copy, description: "Copies the contents of all war applications into the dev ear file") {
  destinationDir bigEar
  glasir.model.webModules.findAll{!it.isAtgCore}.each { m ->
    into( m.dir.name ) {
      from m.dir
    }
  }
}

task sync {
  description = "Sync dev web assets (use this after devDeploy has been performed at least once)"  
  dependsOn = [copyDocRoot, copyWars]
}


task copyJBossServers(type: Copy, description: "Creates a dev server setup in your jboss installation") {
  file("$rootDir/servers").eachDir { nodeDir -> 
    destinationDir = file("$jBossRoot/server")
    into(nodeDir.name) {
      from("$jBossRoot/server/default")
      from("$nodeDir/jboss") 
    }
    into("${nodeDir.name}/deploy") {
      from(assembleDevEar.virtualEarFile)
    }
  }
}


task copyAtgServers(type: Copy, description: "Copies all atg server definitions into the ATG-Data/servers directory") {
  file("$rootDir/servers").eachDir { nodeDir -> 
    destinationDir = file("$jBossRoot/ATG-Data/servers")
    into(nodeDir.name) {
      from("$nodeDir/atg") 
    }
  }
}

task devDeploy {
  description = "Compile, test, assemble, and deploys the dev ear to jboss"  
  dependsOn = [assembleDevEar, copyDocRoot, copyAtgServers, copyJBossServers]
}

devDeploy << {
  if (!onWindows) {
    glasir.model.webModules.findAll{!it.isAtgCore}.each { m ->
      def linkName="${bigEar.absolutePath}/${m.dir.name}"
      glasir.deleteDir(linkName)
      ant.symlink( link: linkName, resource: m.dir, overwrite: true)
    }
  }
}

task cleanLocalDatabase(dependsOn: ['clean']) << {
  description = "Cleans out the local database, if any"
  glasir.deleteDir(databaseDir)
}

task cleanJbossServers(dependsOn: ['clean']) << {
  description = "Cleans out the jboss server dirs"
  glasir.deleteDir("$jBossRoot/server/${storeServerName}")
  glasir.deleteDir("$jBossRoot/server/${adminServerName}")
  glasir.deleteDir("$jBossRoot/ATG-Data")
}

task cleanAll(
  dependsOn: ['clean','cleanJbossServers','cleanLocalDatabase'],
  description: "Cleans out all the 'build' directories in the source tree, the jboss server dirs and the local database, if any") << {}



task createEndecaCrsApp {
  description = "Run Endeca's deploy script to create an Endeca application using default settings for glasir.demo." 

  outputs.upToDateWhen {
    file("$rootDir/endeca/CRS").exists()
  }
}

createEndecaCrsApp << {
  // We want to run this file with certain arguments in a certain environment:
  //$ENDECA_ROOT/../../ToolsAndFrameworks/3.1.2/deployment_template/bin/deploy.sh
  String executableName = "deploy.sh"

  File endecaRoot = new File( endecaDir, "endeca/PlatformServices/6.1.3" )
  File endecaConf = new File( endecaDir, "endeca/PlatformServices/workspace" )
  File toolsDir = new File( endecaDir, "endeca/ToolsAndFrameworks/3.1.2" )
  File toolsBinDir = new File( toolsDir, "deployment_template/bin" )
  File appRoot = new File( rootDir, "endeca" )
  ant.mkdir( dir:appRoot )


  // Create the input file, defining the Endeca application.
  File silentInput = File.createTempFile("temp","crs")
  def s = System.properties["line.separator"]
  def appName = "CRS"
  silentInput.write "y${s}${appName}${s}${appRoot}${s}8888${s}8006${s}15000${s}15002${s}15010${s}"


  // Log some values to help with problems.
  println "silent input name: $silentInput"
  println "silent input text: ${silentInput.text}"
  println "toolsBinDir      : $toolsBinDir"
  println "executable       : $executableName"
  println "endecaRoot       : $endecaRoot"
  println "endecaConf       : $endecaConf"


  // Set up the environment
  def environment = System.getenv()
  def ENDECA_ROOT = endecaRoot

  def PERLLIB = environment['PERLLIB']
  PERLLIB = "$ENDECA_ROOT/lib/perl:$ENDECA_ROOT/lib/perl/Control:$ENDECA_ROOT/perl/lib:$ENDECA_ROOT/perl/lib/site_perl:$PERLLIB"

  def PERL5LIB = environment['PERL5LIB']
  PERL5LIB = "$ENDECA_ROOT/lib/perl:$ENDECA_ROOT/lib/perl/Control:$ENDECA_ROOT/perl/lib:$ENDECA_ROOT/perl/lib/site_perl"
  if(environment['PERL5LIB']) { PERL5LIB += ":" + environment['PERL5LIB'] }

  def PATH = environment['PATH']
  PATH="$ENDECA_ROOT/bin:$ENDECA_ROOT/perl/bin:$ENDECA_ROOT/utilities:$PATH"

  println "perllib  : $PERLLIB"
  println "perl5lib : $PERL5LIB"
  println "path : $PATH"


  // Run the deployment script.
  ant.exec( executable:executableName, dir:toolsBinDir, input:silentInput, resolveexecutable:true ) {
    env( key:"ENDECA_ROOT", file:endecaRoot )
    env( key:"ENDECA_CONF", file:endecaConf )
    env( key:"PERLLIB", value:PERLLIB )
    env( key:"PERL5LIB", value:PERL5LIB )
    env( key:"PATH", value:PATH )
  }
}

