tasks.addRule("""\
Pattern: print<AtgModuleName>: Prints a module dependency tree for an atg module
         Example: 'gradle printDCS.Search.Order.Index' will print out dependency tree for
                  module 'DCS.Search.Order.Index'""") { String taskName ->
  if (taskName.startsWith("print")) {
    task(taskName) << {
      printTree(taskName - "print")
    }
  }
}

tasks.addRule("""\
Pattern: checkManifest<AtgModuleName>: Checks the module MANIFEST.MF against the contents of 
         the <module root>/lib directory to see if the ATG-Class-Path contains all the jars 
         in the lib directory and vice versa""") { String taskName ->
  if (taskName.startsWith("checkManifest")) {
    task(taskName) << {
      def moduleName = (taskName - "checkManifest")
      def m = module(moduleName)
      Set<File> cpFiles = m.fullClasspath
      Set<File> libFiles = []      
      new File(m.dir, "lib").eachFileRecurse { f -> 
        libFiles << f
      }
    
      def inCpNotInLib = (cpFiles - libFiles).findAll { it.canonicalPath.contains(m.dir.canonicalPath) } 
      if (inCpNotInLib) {
        println "Files referred to in MANIFEST.MF ATG-Class-Path that do not exist on disk:"
        (inCpNotInLib).sort { a, b -> a.name.compareTo(b.name) }.each {
          if (!it.canonicalPath.contains(m.dir.canonicalPath)) return
          println "  $it"
        }
      } else {
        println "All the files in the MANIFEST.MF ATG-Class-Path attribute exist - OK" 
      }
      
      println ""
      def inLibNotInCp = (libFiles - cpFiles)
      if (inLibNotInCp) {
        println "Files in <moduleDir>/lib which are not referred to in MANIFEST.MF ATG-Class-Path:"
        inLibNotInCp.sort { a, b -> a.name.compareTo(b.name) }.each {
          println "  $it"
        }      
      } else {
        println "All the files <moduleDir>/lib are referred to in MANIFEST.MF ATG-Class-Path - OK" 
      }
    }
  }
}


import groovyx.net.http.HTTPBuilder
import static groovyx.net.http.Method.*
import static groovyx.net.http.ContentType.*


tasks.addRule("""\
Pattern: graph<AtgModuleName>: draws a graphical dependency graph for the specified ATG module""") { String taskName ->
  if (taskName.startsWith("graph")) {
    task(taskName) << {
      def moduleName = taskName - 'graph'
      def m = glasir.moduleMap[moduleName]
      if (!m) {
        throw new GradleException("Unable to locate module '$moduleName'")
      }

      def dotGraph = createDotGraph(m)
      //println "DOTGRAPH: \n$dotGraph"
      def graphFile = file("$buildDir/reports/graph-${moduleName}.png")
      if (!graphFile.parentFile.exists()) {
        mkdir(graphFile.parentFile) 
      }
      
      //see the following url for details on the below:
      //http://code.google.com/apis/chart/image/docs/gallery/graphviz.html
      def http = new HTTPBuilder( 'http://chart.googleapis.com' )
      http.post(path: '/chart', 
                body: [cht: 'gv', chof: 'png', chl: dotGraph], 
                requestContentType: URLENC ,
                contentType: BINARY)  { resp, reader ->
        if (resp.statusLine.statusCode != 200) {        
          println "---------- Error response received from Google Charts API ----------"
          println "Response status line: ${resp.statusLine}"
          println "Response status code: ${resp.statusLine.statusCode}"
          throw new GradleException("Chart generation failed")
        }
                
        graphFile.withOutputStream{ out ->
          out << reader
        }   
      } 
    
      println ""
      println "> Module dependency graph written to: ${(graphFile.absolutePath - projectDir.absolutePath)[1..-1]}"
    }    
  }
}


String createDotGraph(m) {
  Set<String> edges = [] as Set
  Map nodes = [:]
  createDotGraphRecursive(nodes, edges, m)      
  
  StringBuilder dotGraph = new StringBuilder("digraph Compile { \n")
  nodes.each { module, node -> 
    dotGraph << node << "\n"
  }
  edges.each { edge -> 
    dotGraph << edge << "\n"
  }
  dotGraph << "}" << "\n"
  
  dotGraph.toString()
}

def createDotGraphRecursive(nodes, edges, parent) {  
  createDotGraphNode(nodes, parent)
  
  def size = parent.requiredModules.size()  
  parent.requiredModules.eachWithIndex { child, index ->    
    createDotGraphEdge(edges, parent, child, index, size)     
    createDotGraphRecursive(nodes, edges, child)
  }  
}

//SourceLoc -> Target [pos="e,711,460 858,509 819,497 760,477 721,463", _draw_="c 5 -black B 4 858 509 819 497 760 477 721 463 ", _hdraw_="S 5 -solid S 15 -setlinewidth(1) c 5 -black C 5 -black P 3 722 460 711 460 720 466 "];
def createDotGraphEdge(edges, parent, child, index, size) {
  def edge = "  \"${parent.name}\" -> \"${child.name}\""
  
  if (size > 1) edge += "[label=\"${index+1}\"]" 

  edges << edge
}

//AbstractMemory [pos="1134,306", width="2.06", height="0.50", _draw_="c 5 -black e 1134 306 74 18 ", _ldraw_="F 14.000000 11 -Times-Roman c 5 -black T 1134 301 0 123 14 -AbstractMemory "];
def createDotGraphNode(nodes, module) {
 if (nodes.containsKey(module)) return 
 
 def node = "  \"${module.name}\""
 if (!module.isAtgCore) node += '[fontcolor=blue]'
 
 nodes[module] = node
}
